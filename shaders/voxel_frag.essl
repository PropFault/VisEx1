#ifndef GL_ES
#version 330 es
#endif

precision highp sampler3D;
uniform sampler3D map;
uniform vec3 boundingBox[2];
uniform float samples;
uniform float iso;
uniform vec3 cameraPos;
uniform vec3 objectColor;
uniform vec3 ambientColor;
uniform vec3 lightColor;

out vec4 fragColor;
varying vec3 vDir;
varying vec3 vOrigin;
varying vec3 vPos;


float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(){
    vec3 dir = normalize(vDir);
    vec3 inv_dir = 1.0 / dir;
    float lastRead = 0.0;
    vec3 lastPos = vec3(0.0f,0.0f,0.0f);

    vec3 sides = boundingBox[1] - boundingBox[0];


    // slab
    vec3 t1 = (boundingBox[0] - vOrigin) * inv_dir;
    vec3 t2 = (boundingBox[1] - vOrigin) * inv_dir;

    vec3 tminv = min(t1, t2);
    vec3 tmaxv = max(t1, t2);

    float tmin = max(tminv.x, min(tminv.y, tminv.z));
    float tmax = min(tmaxv.x, max(tmaxv.y, tmaxv.z));

    if(tmin > tmax){
        discard;
    }
    tmin = max(tmin, 0.0); // ensure bigger than 0
    vec3 cursor = vOrigin + tmin * dir;

    // Add some noise to the cursor

    float span = (tmax - tmin);
    float maxSide = max(sides.z, max(sides.x, sides.y));
    float delta = maxSide / samples; // 2000 samples

    vec3 firstHit = vec3(0.0f,0.0f,0.0f);
    vec3 gradient = vec3(0.0f, 0.0f, 0.0f);
    bool hit = false;
    for(float c = tmin; c < tmax; c += delta){
        vec3 p =  (cursor / sides) + 0.5;
        if(p.x >= 0.0 && p.y >= 0.0 && p.z >= 0.0
            && p.x <= 1.0 && p.y <= 1.0 && p.z <= 1.0){ // if p is within texture
            float curRead = texture(map, p).r;
            if(lastRead < iso && curRead > iso){
                hit = true;
                float eps = 0.0001; // some small value
                float interp = (iso - lastRead) / (curRead - lastRead);
                firstHit = lastPos + ((lastPos - p) * interp);
                gradient = normalize(vec3(
                    (texture(map, vec3(firstHit.x - eps, firstHit.y, firstHit.z)).r - texture(map, vec3(firstHit.x + eps, firstHit.y, firstHit.z)).r) / 2.0,
                    (texture(map, vec3(firstHit.x, firstHit.y - eps, firstHit.z)).r - texture(map, vec3(firstHit.x, firstHit.y + eps, firstHit.z)).r) / 2.0,
                    (texture(map, vec3(firstHit.x, firstHit.y, firstHit.z - eps)).r - texture(map, vec3(firstHit.x, firstHit.y, firstHit.z + eps)).r) / 2.0
                ));
                break;
            }

            lastRead = curRead;
        }
        lastPos = p;
        cursor += dir * delta;
    }
    if(!hit){
        discard;
        return;
    }
    //basic values
    float specularStrength = iso;
    vec3 lightDir = normalize(cameraPos - firstHit);
    vec3 reflectDir = reflect(-lightDir, gradient);


    //diffuse
    vec3 diffuse = lightColor* max(dot(gradient, lightDir), 0.0);
    //specular
    float spec = pow(max(dot(lightDir, reflectDir), 0.0), 32.0);
    vec3 specular = specularStrength * spec * lightColor;

    // Calculate final color
    vec3 color = (ambientColor + diffuse + specular) * objectColor;
    //clamp color
    color.x = max(min(color.x, 1.0f), 0.0f);
    color.y = max(min(color.y, 1.0f), 0.0f);
    color.z = max(min(color.z, 1.0f), 0.0f);
    fragColor = vec4(color.x, color.y, color.z, 1.0);
}
